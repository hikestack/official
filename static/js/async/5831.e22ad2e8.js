"use strict";(self.webpackChunk_hikestack_official=self.webpackChunk_hikestack_official||[]).push([["5831"],{3911:function(e,n,r){r.r(n),r.d(n,{default:function(){return t}});var s=r(2322),i=r(2840);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",code:"code"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"控制反转",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#控制反转",children:"#"}),"控制反转"]}),"\n",(0,s.jsx)(n.p,{children:"IoC，即控制反转，是一种编程思想，其主要目的是将原本由代码直接操控的对象的调用权交给第三方（通常是一个容器）来控制，以解耦代码，提高可维护性。"}),"\n",(0,s.jsx)(n.p,{children:"IoC 容器负责创建对象、管理对象之间的关系，并在需要的时候将对象注入到代码中。这样，代码就不再直接依赖于具体的对象实例，而是依赖于 IoC 容器的配置和注入。"}),"\n",(0,s.jsx)(n.p,{children:"在 Web 框架中，IoC 容器的使用非常广泛。框架可以通过 IoC 容器来管理各个组件（如控制器、服务、中间件等）的生命周期和依赖关系，从而实现组件之间的松耦合和高内聚。同时，IoC 容器还可以方便地实现依赖注入，使得代码更加简洁和易于测试。"}),"\n",(0,s.jsxs)(n.h2,{id:"ioc-容器的实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ioc-容器的实现",children:"#"}),"IoC 容器的实现"]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们将从零开始，使用 TypeScript 实现一个简单的 IoC 容器。"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"定义容器接口"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"首先，我们需要定义一个 IoC 容器的接口，规定容器需要实现的方法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",meta:"",children:"interface IContainer {\n  register<T>(key: symbol, instance: { new (...args: any[]): T }): void;\n  resolve<T>(key: symbol): T;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们定义了两个方法：",(0,s.jsx)(n.code,{children:"register"})," 用于将类型与实现绑定，",(0,s.jsx)(n.code,{children:"resolve"})," 用于根据类型获取实例。"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"实现容器类"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们实现 IoC 容器的具体类。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",meta:"",children:"class Container implements IContainer {\n  private registry: Map<symbol, any> = new Map();\n\n  register<T>(key: symbol, instance: { new (...args: any[]): T }): void {\n    this.registry.set(key, instance);\n  }\n\n  resolve<T>(key: symbol): T {\n    const instance = this.registry.get(key);\n    if (!instance) {\n      throw new Error(`Service ${key.description} not registered.`);\n    }\n    return new instance() as T;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"Container"})," 类中，我们使用 ",(0,s.jsx)(n.code,{children:"Map"})," 来存储类型与实现的映射关系。",(0,s.jsx)(n.code,{children:"register"})," 方法用于添加映射，",(0,s.jsx)(n.code,{children:"resolve"})," 方法用于根据类型获取实例。"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"使用 IoC 容器"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["现在我们可以使用 ",(0,s.jsx)(n.code,{children:"Container"})," 来管理对象的依赖关系。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",meta:"",children:"// 定义服务接口\ninterface IUserService {\n  getUserById(id: number): any;\n}\n\n// 实现服务接口\nclass UserService implements IUserService {\n  getUserById(id: number) {\n    // 模拟从数据库获取用户信息的操作\n    return { id, name: `User ${id}` };\n  }\n}\n\n// 创建 IoC 容器实例\nconst container = new Container();\n\n// 注册服务实现到容器\nconst userServiceKey = Symbol('UserService');\ncontainer.register<IUserService>(userServiceKey, UserService);\n\n// 从容器中解析服务实例\nconst userService: IUserService = container.resolve<IUserService>(userServiceKey);\n\n// 使用服务实例\nconst user = userService.getUserById(1);\nconsole.log(user);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在上面的示例中，我们首先定义了一个 ",(0,s.jsx)(n.code,{children:"IUserService"})," 接口和一个实现该接口的 ",(0,s.jsx)(n.code,{children:"UserService"})," 类。然后，我们创建了一个 ",(0,s.jsx)(n.code,{children:"Container"})," 实例，并使用 ",(0,s.jsx)(n.code,{children:"register"})," 方法将 ",(0,s.jsx)(n.code,{children:"IUserService"})," 绑定到一个唯一的 ",(0,s.jsx)(n.code,{children:"Symbol"})," 上。最后，我们通过 ",(0,s.jsx)(n.code,{children:"resolve"})," 方法从容器中获取 ",(0,s.jsx)(n.code,{children:"IUserService"})," 的实例，并调用其方法来获取用户信息。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,s.jsx)(n.p,{children:"通过本文的介绍，我们了解了 IoC 容器的概念和在 Web 框架中的用法，并从零开始实现了一个简单的 IoC 容器。这个容器虽然简单，但已经具备了 IoC 容器的基本功能。在实际项目中，我们需要更复杂的 IoC 容器来支持更多的功能，如依赖注入的自动解析、生命周期管理等。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(c,e)})):c(e)}let t=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["guide%2Fdocs%2Fioc.mdx"]={toc:[{id:"ioc-容器的实现",text:"IoC 容器的实现",depth:2},{id:"总结",text:"总结",depth:2}],title:"控制反转",frontmatter:{}}}}]);
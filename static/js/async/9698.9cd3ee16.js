"use strict";(self.webpackChunk_hikestack_official=self.webpackChunk_hikestack_official||[]).push([["9698"],{109:function(e,n,r){r.r(n),r.d(n,{default:function(){return c}});var i=r(1549),s=r(6603);function o(e){let n=Object.assign({h1:"h1",a:"a",code:"code",p:"p",h2:"h2",pre:"pre"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"keyof-和infer",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#keyof-和infer",children:"#"}),(0,i.jsx)(n.code,{children:"keyof"})," 和",(0,i.jsx)(n.code,{children:"infer"})]}),"\n",(0,i.jsxs)(n.p,{children:["在 TypeScript 的类型系统中，",(0,i.jsx)(n.code,{children:"keyof"})," 和 ",(0,i.jsx)(n.code,{children:"infer"})," 是两个非常强大的工具，它们允许开发者以更加灵活和精确的方式操作类型。这两个特性在构建泛型库、处理复杂数据结构或实现类型安全的 API 时尤为重要。本文将通过解析一个 OAuth 服务的实现代码，来深入探讨 ",(0,i.jsx)(n.code,{children:"keyof"})," 和 ",(0,i.jsx)(n.code,{children:"infer"})," 的用法及其在实际开发中的应用。"]}),"\n",(0,i.jsxs)(n.h2,{id:"keyof获取对象键的类型",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#keyof获取对象键的类型",children:"#"}),(0,i.jsx)(n.code,{children:"keyof"}),"：获取对象键的类型"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"keyof"})," 类型操作符用于获取一个对象类型中所有键的联合类型。这在处理动态属性名或需要根据对象键来构建类型时非常有用。"]}),"\n",(0,i.jsxs)(n.p,{children:["例如，在 OAuth 服务的上下文中，我们可能有一个配置对象 ",(0,i.jsx)(n.code,{children:"OAuthModuleOptions"}),"，它包含一个 ",(0,i.jsx)(n.code,{children:"providers"})," 属性，该属性是一个映射到不同 OAuth 提供者配置的对象。使用 ",(0,i.jsx)(n.code,{children:"keyof"}),"，我们可以轻松地获取这些提供者键的类型："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",meta:"",children:'type IAuthorizationOptions = {...};\ntype IAccessTokenOptions = {...};\ntype IUserInfoOptions = {...};\n\ninterface OAuthProvider<\n	IAuthorizationOptions,\n	IAccessTokenOptions,\n	IUserInfoOptions,\n> {\n	getAuthorizationUrl(options?: IAuthorizationOptions): Promise<string>;\n	getAccessToken(options: IAccessTokenOptions): Promise<string>;\n	getUserInfo<TUserInfo = any>(options: IUserInfoOptions): Promise<TUserInfo>;\n}\n\ninterface OAuthModuleOptions {\n  providers: {\n    [key: string]: OAuthProvider<IAuthorizationOptions, IAccessTokenOptions, IUserInfoOptions>;\n  };\n}\n\ntype ProviderKey = keyof OAuthModuleOptions["providers"];\n'})}),"\n",(0,i.jsxs)(n.p,{children:["在这个例子中，",(0,i.jsx)(n.code,{children:"ProviderKey"})," 将是一个字符串字面量类型的联合，包含了 ",(0,i.jsx)(n.code,{children:'OAuthModuleOptions["providers"]'})," 对象中所有键的类型。"]}),"\n",(0,i.jsxs)(n.h2,{id:"infer在条件类型中推断类型",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#infer在条件类型中推断类型",children:"#"}),(0,i.jsx)(n.code,{children:"infer"}),"：在条件类型中推断类型"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"infer"})," 关键字用于在条件类型内部推断出一个类型。它通常与 ",(0,i.jsx)(n.code,{children:"extends"})," 子句一起使用，允许开发者基于某个类型的结构来构造一个新的类型。"]}),"\n",(0,i.jsxs)(n.p,{children:["在 OAuth 服务的实现中，",(0,i.jsx)(n.code,{children:"infer"})," 被用来推断 ",(0,i.jsx)(n.code,{children:"getAuthorizationUrl"}),"、",(0,i.jsx)(n.code,{children:"getAccessToken"})," 和 ",(0,i.jsx)(n.code,{children:"getUserInfo"})," 方法的参数类型。这些方法的参数类型取决于具体的 OAuth 提供者实现。通过使用 ",(0,i.jsx)(n.code,{children:"infer"}),"，我们可以确保在调用这些方法时，提供的参数类型与提供者期望的类型相匹配。"]}),"\n",(0,i.jsxs)(n.p,{children:["例如，在 ",(0,i.jsx)(n.code,{children:"getAuthorizationUrl"})," 方法中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",meta:"",children:'async getAuthorizationUrl<\n  T extends OAuthProvider<IAuthorizationOptions, IAccessTokenOptions, IUserInfoOptions>,\n>(\n  provider: ProviderKey,\n  options?: T["getAuthorizationUrl"] extends (arg: infer P) => any ? P : never,\n): Promise<string> {\n  // 方法实现\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["在这个例子中，",(0,i.jsx)(n.code,{children:"T"})," 是一个泛型参数，它扩展了 ",(0,i.jsx)(n.code,{children:"OAuthProvider"})," 接口。我们使用 ",(0,i.jsx)(n.code,{children:'T["getAuthorizationUrl"] extends (arg: infer P) => any ? P : never'})," 来推断 ",(0,i.jsx)(n.code,{children:"getAuthorizationUrl"})," 方法的参数类型。如果 ",(0,i.jsx)(n.code,{children:"T"})," 的 ",(0,i.jsx)(n.code,{children:"getAuthorizationUrl"})," 方法接受一个参数，那么 ",(0,i.jsx)(n.code,{children:"P"})," 将是这个参数的类型；否则，参数类型将是 ",(0,i.jsx)(n.code,{children:"never"}),"（表示不存在）。"]}),"\n",(0,i.jsxs)(n.h2,{id:"结合使用keyof-和infer",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结合使用keyof-和infer",children:"#"}),"结合使用",(0,i.jsx)(n.code,{children:"keyof"})," 和",(0,i.jsx)(n.code,{children:"infer"})]}),"\n",(0,i.jsxs)(n.p,{children:["在 OAuth 服务的实现中，",(0,i.jsx)(n.code,{children:"keyof"})," 和 ",(0,i.jsx)(n.code,{children:"infer"})," 被巧妙地结合在一起，以提供类型安全的 API。通过 ",(0,i.jsx)(n.code,{children:"keyof"}),"，我们可以确保传入的提供者键是有效的；通过 ",(0,i.jsx)(n.code,{children:"infer"}),"，我们可以确保传入的参数类型与提供者期望的类型相匹配。"]}),"\n",(0,i.jsx)(n.p,{children:"这种类型安全的保证对于开发大型应用程序或库来说至关重要，因为它可以减少运行时错误，提高代码的可维护性和可读性。"}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"keyof"})," 和 ",(0,i.jsx)(n.code,{children:"infer"})," 是 TypeScript 类型系统中的两个强大工具，它们允许开发者以更加灵活和精确的方式操作类型。通过理解这两个特性的工作原理，开发者可以构建出更加健壮、类型安全的代码库。在 OAuth 服务的实现中，我们看到了这两个特性如何协同工作，以提供类型安全的 API，并确保在调用这些方法时提供的参数类型与提供者期望的类型相匹配。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(o,e)})):o(e)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["guide%2Fbackend%2Fdocs%2Fts-keyof-infer.mdx"]={toc:[{id:"keyof获取对象键的类型",text:"`keyof`：获取对象键的类型",depth:2},{id:"infer在条件类型中推断类型",text:"`infer`：在条件类型中推断类型",depth:2},{id:"结合使用keyof-和infer",text:"结合使用`keyof` 和`infer`",depth:2},{id:"总结",text:"总结",depth:2}],title:"`keyof` 和`infer`",frontmatter:{}}}}]);
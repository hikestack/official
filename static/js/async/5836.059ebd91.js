"use strict";(self.webpackChunk_hikestack_official=self.webpackChunk_hikestack_official||[]).push([["5836"],{3589:function(n,e,r){r.r(e),r.d(e,{default:function(){return l}});var i=r(1549),t=r(6603);function s(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",strong:"strong",ol:"ol",li:"li"},(0,t.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"领域特定语言",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#领域特定语言",children:"#"}),"领域特定语言"]}),"\n",(0,i.jsxs)(e.h2,{id:"什么是领域特定语言dsl",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是领域特定语言dsl",children:"#"}),"什么是领域特定语言(DSL)"]}),"\n",(0,i.jsx)(e.p,{children:"DSL（领域特定语言）是一种针对特定应用领域设计的编程语言或标记语言，旨在提供比通用编程语言更简洁、更直观的语法和工具集，以便开发者能够更高效地完成特定任务。DSL 的出现大大简化了复杂领域的工作流程，提高了开发效率，降低了出错率。"}),"\n",(0,i.jsx)(e.p,{children:"以 Prisma 模型为例，它是一种用于定义和操作数据库模式的 DSL。Prisma 模型提供了一种直观、简洁的方式来描述数据库中的实体、关系以及它们之间的约束。通过定义 Prisma 模型，开发者可以清晰地表达数据库的结构和规则，而无需直接编写繁琐的 SQL 语句或 ORM 配置。"}),"\n",(0,i.jsx)(e.p,{children:"这是一个定义 Prisma Schema 的例子:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:"model User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String?\n  role    Role     @default(USER)\n  posts   Post[]\n  profile Profile?\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"创建一个 DSL 的步骤如下:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:"+----------------+    +----------------+    +----------------+\n| 定义DSL语法    | --\x3e | 编写解析器      | --\x3e | 实现解释器/编译器 |\n+----------------+    +----------------+    +----------------+\n        ^                     |                      |\n        |                     V                      V\n        |                +----------------+    +----------------+\n        |                | 生成AST（抽象  | --\x3e | 生成目标代码   |\n        |                | 语法树）        |    +----------------+\n        |                +----------------+\n        |\n        +-----------------------------------------------------+\n"})}),"\n",(0,i.jsx)(e.p,{children:"那么如何为上面的 Prisma 模型创建一个解析器呢？"}),"\n",(0,i.jsxs)(e.h2,{id:"解析器原理",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解析器原理",children:"#"}),"解析器原理"]}),"\n",(0,i.jsx)(e.p,{children:"解析器主要涉及到词法分析和语法分析两个关键步骤。"}),"\n",(0,i.jsx)(e.p,{children:"词法分析（也称为扫描器或词法器）根据语言的词法规则，从左到右扫描源程序的字符，将其分割成一个个 Token，并为每个 Token 附上相应的属性（如 Token 的类型、值等）。"}),"\n",(0,i.jsx)(e.p,{children:"语法分析，这一步使用语法规则集合（通常以文法的形式表示）来分析 Token 序列，确定它们之间的关系和结构。语法分析器会检查 Token 序列是否符合预定义的语法规则，从而验证输入数据是否满足特定的语法要求。"}),"\n",(0,i.jsx)(e.p,{children:"这是一个 TypeScript 实现词法分析器的例子:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",meta:"",children:"type TokenType = 'INTEGER' | 'PLUS' | 'MINUS' | 'EOF';\n\ninterface Token {\n  type: TokenType;\n  value?: string | number;\n}\n\nclass Lexer {\n  private text: string;\n  private position: number = 0;\n  private currentChar: string = '';\n\n  constructor(text: string) {\n    this.text = text;\n    this.advance();\n  }\n\n  private advance() {\n    this.position++;\n    if (this.position > this.text.length - 1) {\n      this.currentChar = 'EOF';\n    } else {\n      this.currentChar = this.text[this.position];\n    }\n  }\n\n  private isDigit(char: string): boolean {\n    return /[0-9]/.test(char);\n  }\n\n  private isWhitespace(char: string): boolean {\n    return /\\s/.test(char);\n  }\n\n  nextToken(): Token {\n    while (this.currentChar !== 'EOF') {\n      // 忽略空白字符\n      if (this.isWhitespace(this.currentChar)) {\n        this.advance();\n        continue;\n      }\n\n      if (this.isDigit(this.currentChar)) {\n        let value = '';\n        // 收集整数数字\n        while (this.isDigit(this.currentChar)) {\n          value += this.currentChar;\n          this.advance();\n        }\n        return { type: 'INTEGER', value: parseInt(value, 10) };\n      }\n\n      if (this.currentChar === '+') {\n        this.advance();\n        return { type: 'PLUS' };\n      }\n\n      if (this.currentChar === '-') {\n        this.advance();\n        return { type: 'MINUS' };\n      }\n\n      // 如果当前字符不是数字、加号或减号，则抛出错误\n      throw new Error(`Unexpected character: ${this.currentChar}`);\n    }\n\n    return { type: 'EOF' };\n  }\n}\n\nconst lexer = new Lexer('100 + 200 - 300');\nlet token: Token;\nwhile ((token = lexer.nextToken()).type !== 'EOF') {\n  console.log(token);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"nextToken 方法是词法分析器的核心，它不断读取字符并根据词法规则返回相应的记号。当遇到数字时，它会收集所有连续的数字字符并返回一个 INTEGER 类型的记号；当遇到加号或减号时，它会返回相应的记号；当遇到其他字符时，它会抛出一个错误。循环不断调用 nextToken 方法，直到返回 EOF 记号为止。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"解析器生成器"})}),"\n",(0,i.jsx)(e.p,{children:"手动编写解析器是一个复杂且漫长的过程，在实际开发中一般使用解析器生成器来创建解析器。peg.js 是一种基于 Parsing Expression Grammar（解析表达式语法）的解析器生成器，PEG 类似于正则表达式和巴科斯范式 BNF，我们使用它来生成一个 Prisma 模型解析器。"}),"\n",(0,i.jsx)(e.p,{children:"为了简单起见我们简化模型如下:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:"model User {\n  id      Int\n  email   String\n  name    String?\n}\n"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"定义模型语法"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:'// prisma.pegjs\nstart\n  = model EOF\n\n\n// 这一行的意思是 model 由 "model"字符 + 空白字符(至少一个或多个) + "{" 字符 + 空白字符(零个或多个) + fields + 空白字符(零个或多个) + "}" 组成\nmodel\n  = "model" space+ identifier space* "{" space* fields space* "}"\n\n// fields 由 field(至少一个或多个) 组成\nfields\n  = field+\n\n// field 由 空白字符(零个或多个) + identifier + 空白字符(零个或多个) + fieldType (空白字符(零个或多个) + "?"字符)(可以为空) + 空白字符(零个或多个) 组成\nfield\n  = space* identifier space+ fieldType (space* "?")? space*\n\n// identifier 由小写字母或大写字母开头 小写字母或大写字母+数字和下划线（零个或多个）组成\nidentifier\n  = [a-zA-Z_] [a-zA-Z0-9_]*\n\n// fieldType 由 "Int"字符 或 "String"字符 或 identifier 组成\nfieldType\n  = "Int" / "String" / identifier\n\n// stringLiteral 由 " 开始 + 中间不为 " 和 any 的字符（零个或多个）+ " 结尾 组成\nstringLiteral\n  = "\\"" (!"\\"" any)* "\\""\n\n// space 由 空格 或 \\t 或 \\n 或 \\r 组成\nspace\n  = " " / "\\t" / "\\n" / "\\r"\n\n// 不为换行符的任意字符\nany\n  = .\n\nEOF\n  = !.\n'})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:"生成解析器"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:"npx pegjs parser.pegjs\n"})}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsx)(e.li,{children:"使用解析器"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",meta:"",children:"// index.js\nconst parser = require('./parser');\n\nconst input = `model User {\n  id      Int\n  email   String\n  name    String?\n}`;\n\nconst ast = parser.parse(input);\nconsole.log(JSON.stringify(ast, null, 2));\n"})}),"\n",(0,i.jsxs)(e.ol,{start:"4",children:["\n",(0,i.jsx)(e.li,{children:"运行"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{meta:"",children:'node index.js\n\n// 输出 AST\n[\n  [\n    "model",\n    [\n      " "\n    ],\n    [\n      "U",\n      [\n        "s",\n        "e",\n        "r"\n      ]\n    ],\n    [\n      " "\n    ],\n    "{",\n    [\n      "\\n",\n      " ",\n      " "\n    ],\n    [\n      [\n        [],\n        [\n          "i",\n          [\n            "d"\n          ]\n        ],\n        [\n          " ",\n          " ",\n          " ",\n          " ",\n          " ",\n          " "\n        ],\n        "Int",\n        null,\n        [\n          " ",\n          "\\n",\n          " ",\n          " "\n        ]\n      ],\n      [\n        [],\n        [\n          "e",\n          [\n            "m",\n            "a",\n            "i",\n            "l"\n          ]\n        ],\n        [\n          " ",\n          " ",\n          " "\n        ],\n        "String",\n        null,\n        [\n          "\\n",\n          " ",\n          " "\n        ]\n      ],\n      [\n        [],\n        [\n          "n",\n          [\n            "a",\n            "m",\n            "e"\n          ]\n        ],\n        [\n          " ",\n          " ",\n          " ",\n          " "\n        ],\n        "String",\n        [\n          [],\n          "?"\n        ],\n        [\n          " ",\n          "\\n"\n        ]\n      ]\n    ],\n    [],\n    "}"\n  ],\n  null\n]\n'})}),"\n",(0,i.jsx)(e.p,{children:"有了 AST（抽象语法树）之后我们就可以根据 AST 生成 SQL 和 DAO 层代码"}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,i.jsx)(e.p,{children:"DSL（领域特定语言）允许我们以更直观、更贴近业务逻辑的方式表达和解决复杂问题。DSL 能够简化复杂系统的构建和维护过程，提高开发效率，同时减少错误和误解。通过 DSL，我们可以创建出针对特定领域的强大工具，从而推动业务创新和提升软件系统的整体质量。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(s,n)})):s(n)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["guide%2Fdocs%2Fdsl.mdx"]={toc:[{id:"什么是领域特定语言dsl",text:"什么是领域特定语言(DSL)",depth:2},{id:"解析器原理",text:"解析器原理",depth:2},{id:"总结",text:"总结",depth:2}],title:"领域特定语言",frontmatter:{}}}}]);
"use strict";(self.webpackChunk_hikestack_official=self.webpackChunk_hikestack_official||[]).push([["4199"],{3787:function(e,r,c){c.r(r),c.d(r,{default:function(){return t}});var n=c(2322),i=c(2840);function s(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre"},(0,i.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.h1,{id:"循环引用",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#循环引用",children:"#"}),"循环引用"]}),"\n",(0,n.jsxs)(r.p,{children:["在 TypeScript 中，构建大型应用程序或框架时，可能会遇到循环引用的问题。循环引用通常发生在两个或多个模块或类相互依赖，形成一个闭环的情况。这可能导致代码难以维护，甚至在某些情况下引发运行时错误。\n本文将解释什么是循环引用，并通过一个 ",(0,n.jsx)(r.code,{children:"UserService"})," 和 ",(0,n.jsx)(r.code,{children:"OrderService"})," 的例子来说明问题，然后展示如何通过代理（Proxy）和接口（Interface）来解决循环引用。"]}),"\n",(0,n.jsxs)(r.h2,{id:"什么是循环引用",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是循环引用",children:"#"}),"什么是循环引用？"]}),"\n",(0,n.jsx)(r.p,{children:"循环引用是指两个或多个对象或模块相互引用对方，形成一个闭环。在 TypeScript 中，当两个类相互导入对方时，就可能发生循环引用。例如，类 A 依赖于类 B 的实例，而类 B 又依赖于类 A 的实例，这就形成了一个循环引用。"}),"\n",(0,n.jsxs)(r.h2,{id:"userservice-和-orderservice-循环引用示例",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#userservice-和-orderservice-循环引用示例",children:"#"}),"UserService 和 OrderService 循环引用示例"]}),"\n",(0,n.jsxs)(r.p,{children:["考虑一个简单的电商应用，其中 ",(0,n.jsx)(r.code,{children:"UserService"})," 负责处理用户相关的操作，",(0,n.jsx)(r.code,{children:"OrderService"})," 负责处理订单相关的操作。这两个服务在逻辑上可能需要互相调用。"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",meta:"",children:"// user-service.ts\nimport { OrderService } from './order-service';\n\nexport class UserService {\n  constructor(private orderService: OrderService) {}\n\n  // ... UserService 的其他方法\n}\n\n// order-service.ts\nimport { UserService } from './user-service';\n\nexport class OrderService {\n  constructor(private userService: UserService) {}\n\n  // ... OrderService 的其他方法\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["在这个例子中，",(0,n.jsx)(r.code,{children:"UserService"})," 和 ",(0,n.jsx)(r.code,{children:"OrderService"})," 都通过构造函数注入的方式依赖于对方，这直接导致了循环引用。当 TypeScript 编译器尝试编译这些文件时，会抛出一个错误，因为两个类都相互依赖，导致无法解析依赖关系。"]}),"\n",(0,n.jsxs)(r.h2,{id:"使用-proxy-解决循环引用",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-proxy-解决循环引用",children:"#"}),"使用 Proxy 解决循环引用"]}),"\n",(0,n.jsxs)(r.p,{children:["在 TypeScript 中，你可以使用 ES6 的 ",(0,n.jsx)(r.code,{children:"Proxy"})," 对象来动态地处理对象，包括解决循环引用问题。虽然 ",(0,n.jsx)(r.code,{children:"Proxy"})," 本身不直接解决循环引用的问题，但你可以用它来实现一种延迟初始化或懒加载的策略，避免在初始化时直接创建循环依赖。"]}),"\n",(0,n.jsxs)(r.p,{children:["为了解决这个问题，我们可以对 ",(0,n.jsx)(r.code,{children:"UserService"})," 和 ",(0,n.jsx)(r.code,{children:"OrderService"})," 的构造函数进行重构，使其接受工厂函数而不是直接实例，这样我们就可以延迟创建实例，直到真正需要的时候。"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",meta:"",children:"// user-service.ts\nimport { IOrderService } from './IOrderService';\n\nexport class UserService {\n  private orderService: IOrderService;\n\n  constructor(getOrderService: () => IOrderService) {\n    this.orderService = getOrderService();\n  }\n\n  // ... UserService 的其他方法\n}\n\n// order-service.ts\nimport { IUserService } from './IUserService';\n\nexport class OrderService {\n  private userService: IUserService;\n\n  constructor(getUserService: () => IUserService) {\n    this.userService = getUserService();\n  }\n\n  // ... OrderService 的其他方法\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["接下来，我们定义接口，并使用 ",(0,n.jsx)(r.code,{children:"Proxy"})," 来实现延迟初始化的逻辑。"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",meta:"",children:"// IUserService.ts\nexport interface IUserService {\n  // ... UserService 的方法声明\n}\n\n// IOrderService.ts\nexport interface IOrderService {\n  // ... OrderService 的方法声明\n}\n\n// index.ts 或者你的应用启动文件\nimport { UserService } from './user-service';\nimport { OrderService } from './order-service';\nimport { IUserService } from './IUserService';\nimport { IOrderService } from './IOrderService';\n\nconst getUserService = () => {\n  return new UserService(getOrderService);\n};\n\nconst getOrderService = () => {\n  return new OrderService(getUserService);\n};\n\nconst userServiceProxy = new Proxy(getUserService, {\n  apply(target, thisArg, argumentsList) {\n    return Reflect.apply(target, thisArg, argumentsList);\n  },\n});\n\nconst orderServiceProxy = new Proxy(getOrderService, {\n  apply(target, thisArg, argumentsList) {\n    return Reflect.apply(target, thisArg, argumentsList);\n  },\n});\n\nconst userService: IUserService = userServiceProxy();\nconst orderService: IOrderService = orderServiceProxy();\n\n// 现在你可以使用 userService 和 orderService，它们之间不会有循环引用的问题\n"})}),"\n",(0,n.jsxs)(r.p,{children:["在这个解决方案中，",(0,n.jsx)(r.code,{children:"getUserService"})," 和 ",(0,n.jsx)(r.code,{children:"getOrderService"})," 是工厂函数，它们返回 ",(0,n.jsx)(r.code,{children:"UserService"})," 和 ",(0,n.jsx)(r.code,{children:"OrderService"})," 的实例。通过使用 ",(0,n.jsx)(r.code,{children:"Proxy"}),"，我们确保在第一次调用这些工厂函数时，它们会相互调用对方来创建实例，但不会立即形成循环引用，因为实际的创建操作被推迟到了第一次调用代理对象的 ",(0,n.jsx)(r.code,{children:"apply"})," 陷阱时。"]}),"\n",(0,n.jsxs)(r.p,{children:["请注意，这种方法仍然需要小心处理，确保逻辑上 ",(0,n.jsx)(r.code,{children:"UserService"})," 和 ",(0,n.jsx)(r.code,{children:"OrderService"})," 的使用不会造成逻辑上的死循环。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,n.jsx)(r,Object.assign({},e,{children:(0,n.jsx)(s,e)})):s(e)}let t=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["guide%2Fdocs%2Fcircular.mdx"]={toc:[{id:"什么是循环引用",text:"什么是循环引用？",depth:2},{id:"userservice-和-orderservice-循环引用示例",text:"UserService 和 OrderService 循环引用示例",depth:2},{id:"使用-proxy-解决循环引用",text:"使用 Proxy 解决循环引用",depth:2}],title:"循环引用",frontmatter:{}}}}]);
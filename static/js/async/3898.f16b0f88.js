"use strict";(self.webpackChunk_hikestack_official=self.webpackChunk_hikestack_official||[]).push([["3898"],{1790:function(n,e,a){a.r(e),a.d(e,{default:function(){return l}});var s=a(1549),r=a(6603);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",pre:"pre",h3:"h3"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"使用jvm",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用jvm",children:"#"}),"使用JVM"]}),"\n",(0,s.jsxs)(e.p,{children:["有多种途径可以实现Node.js与Java代码之间的跨语言交互，如将Node.js代码编译为",(0,s.jsx)(e.code,{children:"GraalVM"}),"支持的中间语言，或利用C++、Rust等语言编写JNI（Java Native Interface）插件。本文将重点介绍通过",(0,s.jsx)(e.code,{children:"node-gyp"}),"构建自定义Node.js模块的方式来实现这一功能。"]}),"\n",(0,s.jsx)(e.p,{children:"JNI作为Java平台标准版（Java SE Platform）的关键组成部分，为Java代码与其他语言编写的代码之间的交互提供了桥梁。借助JNI，你可以在C/C++代码中调用Java方法，反之亦然。"}),"\n",(0,s.jsx)(e.p,{children:"接下来，我们将通过一个示例来展示如何在C++中使用JNI来实例化一个Java类并调用其方法。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"1. 首先编写一个简单的 Java 类"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'package com.example;  \n  \npublic class MyClass {  \n    public String getMessage(String message) {  \n        return "Hello " + message;  \n    }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"2. 编译 Java 类"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"javac com/example/MyClass.java\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"3. 使用node-gyp构建模块"})}),"\n",(0,s.jsx)(e.p,{children:"创建一个 node-gyp 模块"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"mkdir my-node-app\ncd my-node-app\nnpm install node-gyp node-addon-api\nnode-gyp init\n"})}),"\n",(0,s.jsxs)(e.p,{children:["使用 ",(0,s.jsx)(e.code,{children:"node-gyp init"})," 在当前目录下生成配置文件，包括\xa0",(0,s.jsx)(e.code,{children:"binding.gyp"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"my-node-app/ \n├── binding.gyp \n├── package.json \n└── src/ \n    ├── index.js\n    └── my_node_addon.cpp\n"})}),"\n",(0,s.jsx)(e.p,{children:"创建 my_node_addon.cpp 用于初始化 JVM 和调用 JNI"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",meta:"",children:'// my_node_addon.cpp\n#include <jni.h>  \n#include <dlfcn.h> // 用于动态加载 Java 库  \n#include "node_addon_api.h"   \n  \n// JVM 和 JNIEnv 的全局变量  \nJavaVM* jvm;  \nJNIEnv* jni;  \n  \n// 初始化 JVM\nbool initializeJVM(const char* classPath) {  \n    JavaVMInitArgs vm_args;  \n    JavaVMOption* options = new JavaVMOption[1];  \n    options[0].optionString = const_cast<char*>(classPath);  \n    options[0].ignoreUnrecognized = JNI_FALSE;  \n    vm_args.version = JNI_VERSION_1_8;  \n    vm_args.nOptions = 1;  \n    vm_args.options = options;  \n    vm_args.ignoreUnrecognized = false;  \n  \n    if (JNI_CreateJavaVM(&jvm, (void**)&jni, &vm_args) != JNI_OK) {  \n        return false;  \n    }  \n    return true;  \n}\n  \n// 清理 JVM  \nvoid cleanupJVM() {  \n    if (jvm != nullptr) {  \n        jvm->DestroyJavaVM();  \n        jvm = nullptr;  \n        jni = nullptr;  \n    }  \n}\n\nNapi::Value CallJava(const Napi::CallbackInfo& info) {  \n    Napi::Env env = info.Env();\n    \n    if (info.Length() < 3) {  \n        Napi::TypeError::New(env, "Expected class name, method name, and argument as arguments").ThrowAsJavaScriptException();  \n        return env.Null();  \n    } \n  \n    std::string className = info[0].As<Napi::String>().Utf8Value();  \n    std::string methodName = info[1].As<Napi::String>().Utf8Value();\n    std::string arg = info[2].As<Napi::String>().Utf8Value();\n  \n    // 查找 Java 类  \n    jclass cls = jni->FindClass(className.c_str());  \n    if (cls == nullptr) {  \n        env.ThrowTypeError("Java class not found");  \n        return env.Null();  \n    }  \n  \n    // 获取类的构造方法  \n    jmethodID ctor = jni->GetMethodID(cls, "<init>", "()V");  \n    if (ctor == nullptr) {  \n        env.ThrowTypeError("Constructor not found");  \n        return env.Null();  \n    }  \n  \n    // 创建 Java 类的实例  \n    jobject obj = jni->NewObject(cls, ctor);  \n    if (jni->ExceptionOccurred()) {  \n        jni->ExceptionDescribe();  \n        jni->ExceptionClear();  \n        env.ThrowTypeError("Failed to create Java object");  \n        return env.Null();  \n    }  \n  \n    // 查找实例方法  \n    jmethodID mid = jni->GetMethodID(cls, methodName.c_str(), "()Ljava/lang/String;");  \n    if (mid == nullptr) {  \n        env.ThrowTypeError("Java method not found");  \n        return env.Null();  \n    }\n    \n    jstring argStr = jni->NewStringUTF(arg.c_str()); \n  \n    // 调用实例方法  \n    jstring result = (jstring)jni->CallObjectMethod(obj, mid, argStr);  \n    if (jni->ExceptionOccurred()) {  \n        jni->ExceptionDescribe();  \n        jni->ExceptionClear();  \n        env.ThrowTypeError("Java exception occurred during method call");  \n        return env.Null();  \n    }  \n  \n    // 将 Java 字符串转换为 C++ 字符串并返回给 Node.js  \n    const char* resultChars = jni->GetStringUTFChars(result, nullptr);  \n    std::string resultStr(resultChars);  \n    jni->ReleaseStringUTFChars(result, resultChars);  \n  \n    // 清理本地引用  \n    jni->DeleteLocalRef(obj);  \n    jni->DeleteLocalRef(result);  \n  \n    return Napi::String::New(env, resultStr);  \n}  \n  \nNapi::Object Init(Napi::Env env, Napi::Object exports) {  \n    const char* classPath = "-Djava.class.path=/path/to/your/java/classes"; // Java 类路径  \n    // 初始化 JVM\n    if (!initializeJVM(classPath)) {  \n        throw Napi::Error::New(env, "Failed to initialize JVM");  \n    } \n  \n    // 绑定函数到 exports  \n    exports.Set(Napi::String::New(env, "callJava"), Napi::Function::New(env, CallJava));  \n  \n    // 注册清理 JVM 的钩子  \n    Napi::AddCleanupHook([](void* arg) {   \n        cleanupJVM();  \n    }, nullptr);  \n  \n    return exports;  \n}\n  \nNODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:'// binding.gyp\n{  \n  "targets": [  \n    {  \n      "target_name": "my_node_addon",  \n      "sources": [ "my_node_addon.cpp"],  \n      "include_dirs": ["<!(node -p \\"require(\'node-addon-api\').include\\")"],  \n      "dependencies": ["<!(node -p \\"require(\'node-addon-api\').gyp\\")"],  \n      "cflags!": [ "-fno-exceptions" ],  \n      "cflags_cc!": [ "-fno-exceptions" ],    \n      "conditions": [         \n        [\'OS=="linux"\', {  \n          "cflags+": ["-I/usr/lib/jvm/java-8-openjdk-amd64/include", "-I/usr/lib/jvm/java-8-openjdk-amd64/include/linux"],  \n          "libraries": ["-L/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server", "-ljvm"]  \n        }]  \n      ]  \n    }  \n  ]  \n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"4. 构建插件"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"node-gyp configure build\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"5. 在 Node.js 中使用"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const addon = require('my-node-addon');\n\naddon.callJava('com/example/MyClass', 'getMessage', 'Node.js'); // Hello Node.js\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"使用-node-java-库简化工作流程",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-node-java-库简化工作流程",children:"#"}),"使用 node-java 库简化工作流程"]}),"\n",(0,s.jsxs)(e.p,{children:["使用 ",(0,s.jsx)(e.code,{children:"node-java"}),"\xa0库可以简化 Node.js 调用 Java 代码的过程，因为它提供了一个高级别的接口来加载 Java 类、创建 Java 对象以及调用 Java 方法。使得我们无需直接处理 JNI（Java Native Interface）的复杂性，\n下面我们使用",(0,s.jsx)(e.code,{children:"node-java"}),"完成同样的效果。"]}),"\n",(0,s.jsxs)(e.p,{children:["首先需要安装",(0,s.jsx)(e.code,{children:"node-java"}),"包："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"npm install java\n"})}),"\n",(0,s.jsxs)(e.p,{children:["修改代码使用",(0,s.jsx)(e.code,{children:"node-java"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const java = require('java');  \n\n// 设置 classpath\njava.classpath.push(\"/path/to/your/java/classes\");\n\n// 加载 Java 类  \nconst MyClass = java.import('com.example.MyClass');  \n\nconst myClass = new MyClass();\n// getMessageSync 是 node-java 动态代理的 getMessage 方法的同步版本\nconst result = myClass.getMessageSync('Node.js');  \n\nconsole.log(result); // Hello Node.js\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"在typescript中使用",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#在typescript中使用",children:"#"}),"在TypeScript中使用"]}),"\n",(0,s.jsx)(e.p,{children:"假设你有一个 Web 项目，目录结构如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"web-framework/\n└── java/\n│   ├── lib/                 \n│   │   ├── fastjson-1.2.83.jar\n│   │   └── ...\n│   ├── bin/                 \n│   │   ├── MyClass.class\n│   │   └── ...\n├── src/                         \n│   ├── index.ts                 \n│   ├── service/                 \n│   │   ├── JvmService.ts\n│   │   └── ...\n└── ...                          \n"})}),"\n",(0,s.jsx)(e.p,{children:"将 node-java 封装成一个服务。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:"",children:"// JvmService.ts\nimport { Injectable } from '@nestjs/common';\nimport fg from 'fast-glob';\nimport java from 'java';\nimport path from 'path';\n\n@Injectable()\nexport class JvmService {\n  private readonly jvm: any;\n  constructor() {\n    // 自动扫描所有的 .jar 文件并加入到 classpath\n    fg.globSync('java/lib/*.jar', {\n      cwd: process.cwd(),\n      absolute: true,\n      objectMode: true,\n      unique: true,\n    }).forEach((file) => {\n      console.log('加载jar包:', file.name);\n      java.classpath.push(file.path);\n    });\n    // 将自己编写的 Java 文件加入 classpath\n    java.classpath.push(path.join(process.cwd(), 'java/bin'));\n    this.jvm = java;\n  }\n\n  get JVM() {\n    return this.jvm;\n  }\n\n  import(path: string) {\n    return this.jvm.import(path);\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"使用 JvmService"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:"",children:"@Injectable()\nexport class TestService {\n  constructor(\n    private readonly jvmService: JvmService,\n  ) {\n    const myClass = this.jvmService.import('com/example/MyClass');\n    const result = myClass.getMessageSync('Node.js');  \n\n    console.log(result); // Hello Node.js\n  }\n"})})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(i,n)})):i(n)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["guide%2Fdocs%2Fjvm.mdx"]={toc:[{id:"使用-node-java-库简化工作流程",text:"使用 node-java 库简化工作流程",depth:3},{id:"在typescript中使用",text:"在TypeScript中使用",depth:3}],title:"使用JVM",frontmatter:{}}}}]);
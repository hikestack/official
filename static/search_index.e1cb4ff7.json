[{"id":0,"title":"","content":"","routePath":"/official/api/OpenAPI/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"","content":"","routePath":"/official/api/","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"custom"},"version":""},{"id":2,"title":"元编程","content":"#\n\n元编程本质上是一种编程范式，它允许程序在运行时或编译时生成、修改或操作其他程序（包括它自身）的代码、结构或行为。\n\n元编程为开发者提供了强大的工具和灵活性，以动态地操作和扩展应用程序。装饰器和反射API、TypeScript编译器API，都是在 NestJS\n中常用的实现元编程的策略。\n\n下面，我将对这几种方式进行详细介绍：\n\n\n装饰器和反射API#\n\n创建元数据装饰器\n\n\n\n使用 ModulesContainer 获取所有模块从中获取我们感兴趣的控制器类，然后通过 MetadataScanner 扫描该控制器的所有方法。\n\n\n\n提示\n\n需要先导入 DiscoveryModule 才能使用使用 ModulesContainer 和 MetadataScanner。\n\n\n\n\nTypeScript编译器API#\n\n为了简单起见我们使用 操作 TypeScript 编译器API\n\n加载所有源文件\n\n\n\n可针对感兴趣的文件进行操作\n\n\n\n提示\n\n获取类的所有属性（包括继承的属性）\n\n","routePath":"/official/guide/backend/blog/metadata","lang":"","toc":[{"text":"装饰器和反射API","id":"装饰器和反射api","depth":2,"charIndex":168},{"text":"TypeScript编译器API","id":"typescript编译器api","depth":2,"charIndex":343}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"动态模块","content":"#\n\n使用模块是构建高效、可维护和可扩展的应用程序的关键所在。模块使得开发者能够清晰地分离关注点，将应用程序的不同部分封装到独立的模块中。\n\n以日志模块为例，展示如何创建一个标准的 NestJS 动态模块，以下是详细的步骤指南：\n\n\n目录结构#\n\n首先，你需要为日志模块创建一个基本的文件结构。这通常包括一个模块文件（如 logger.module.ts）、一个服务文件（如\nlogger.service.ts），以及可能需要的接口（interfaces）和适配器（adapters）。\n\n\n\n\n定义接口#\n\n定义服务需要实现的 ILogger 接口，这里直接继承自 Nest 内部提供的 LoggerService 接口。\n\n\n\n在 logger.service.ts 文件中，通过模块配置将具体的实现类传递给服务。\n\n\n\n\n实现服务#\n\nWinstonAdapter 使用 实现实际的日志记录功能，比如将日志信息输出到控制台、文件或其他日志存储系统。\n\n\n\n\n构建模块#\n\nNestJS 提供了一个 ConfigurableModuleBuilder 类用于便捷的构建动态模块的配置。\n\n\n\n使用 @Module 装饰器来定义日志模块。这个模块将包含日志服务作为提供者，并可以配置为动态模块，以便在应用程序的不同部分中按需加载。\n\n\n\n\n注册模块#\n\n由于它是一个动态模块，你可以使用 LoggerModule.register() 或 LoggerModule.registerAsync()\n方法在根模块或其他模块中导入它。\n\n\n\n\n使用服务#\n\n最后，你可以在需要记录日志的地方注入 LoggerService 并使用它的方法。这可以通过构造函数注入或其他依赖注入机制来实现。\n在这个日志模块中，我们通过适配器模式实现了对Winston日志库的封装，使得日志服务能够灵活地切换到不同的日志框架，而无需修改服务调用方的代码。\n\n","routePath":"/official/guide/backend/blog/module","lang":"","toc":[{"text":"目录结构","id":"目录结构","depth":2,"charIndex":116},{"text":"定义接口","id":"定义接口","depth":2,"charIndex":247},{"text":"实现服务","id":"实现服务","depth":2,"charIndex":363},{"text":"构建模块","id":"构建模块","depth":2,"charIndex":431},{"text":"注册模块","id":"注册模块","depth":2,"charIndex":570},{"text":"使用服务","id":"使用服务","depth":2,"charIndex":670}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"介绍","content":"#\n\nHikeStack 是一组精心挑选的工具集，旨在运用最前沿的语言特性和开发工具，帮助开发者轻松构建出强大而稳健的 TypeScript 应用。\n\n\n后端：高效、可维护的 Nest 模块#\n\n在后端方面，HikeStack 充分利用了 TypeScript 的强大类型系统和 NestJS 框架的模块化设计。TypeScript\n的类型系统为开发者提供了强大的类型检查和代码智能提示功能，使得代码更加健壮和易于维护。而 NestJS\n框架则以其优雅的模块化设计著称，它允许开发者将应用程序的不同部分封装到独立的模块中，从而实现了清晰的分离关注点和代码复用。通过结合 TypeScript 和\nNestJS，HikeStack 使得开发者能够轻松地编写高效、可维护的 Nest 模块，为后端服务提供坚实的支撑。\n\n\n前端：丰富的 UI 组件和灵活的样式定制#\n\n在前端方面，HikeStack 则采用了流行的 Tailwind CSS 框架和 ShadcnUI 的 React 组件库。Tailwind CSS\n是一个功能强大、灵活易用的 CSS 框架，它提供了一套实用的 CSS 类，使得开发者能够快速地构建出响应式、美观的页面布局。而 ShadcnUI 则是一个基于\nReact 的 UI 组件库，它提供了一系列高质量的 UI 组件，如按钮、表单、对话框等，使得开发者能够轻松地构建出用户友好的界面。通过结合 Tailwind\nCSS 和 ShadcnUI，HikeStack 为开发者提供了丰富的 UI 组件和灵活的样式定制能力，从而极大地提升了前端开发效率和用户体验。\n\n\n总结#\n\nHikeStack致力于成为开发者在构建高性能、可扩展 TypeScript 应用时的得力助手，帮助开发者快速构建出高质量、可扩展的 TypeScript\n应用。","routePath":"/official/guide/introduction","lang":"","toc":[{"text":"后端：高效、可维护的 Nest 模块","id":"后端高效可维护的-nest-模块","depth":2,"charIndex":76},{"text":"前端：丰富的 UI 组件和灵活的样式定制","id":"前端丰富的-ui-组件和灵活的样式定制","depth":2,"charIndex":358},{"text":"总结","id":"总结","depth":2,"charIndex":691}],"domain":"","frontmatter":{},"version":""}]